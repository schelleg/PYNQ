#   Copyright (c) 2016, Xilinx, Inc.
#   All rights reserved.
# 
#   Redistribution and use in source and binary forms, with or without 
#   modification, are permitted provided that the following conditions are met:
#
#   1.  Redistributions of source code must retain the above copyright notice, 
#       this list of conditions and the following disclaimer.
#
#   2.  Redistributions in binary form must reproduce the above copyright 
#       notice, this list of conditions and the following disclaimer in the 
#       documentation and/or other materials provided with the distribution.
#
#   3.  Neither the name of the copyright holder nor the names of its 
#       contributors may be used to endorse or promote products derived from 
#       this software without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
#   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
#   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
#   PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR 
#   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
#   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
#   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
#   OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
#   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
#   OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
#   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


import numpy as np
import pytest
from pynq import Overlay
from pynq.intf.pattern_generator import _bitstring_to_int
from pynq.intf.pattern_generator import _wave_to_bitstring
from pynq.intf import FSMGenerator


__author__ = "Yun Rock Qu"
__copyright__ = "Copyright 2016, Xilinx"
__email__ = "pynq_support@xilinx.com"


ol = Overlay('interface.bit')


@pytest.mark.run(order=48)
def test_fsm_generator():
    """Test for the Finite State Machine Generator class.

    The pattern generated by the FSM will be compared with the one specified.
    
    """
    if_id = 3
    num_samples = 100
    test_string1 = test_string2 = test_string3 = \
        test_string4 = test_string5 = ''
    fsm_spec = {'inputs': [('rst', 'D0'), ('direction', 'D1')],
                'outputs': [('test', 'D2')],
                'states': ['S0', 'S1', 'S2', 'S3'],
                'transitions': [['00', 'S0', 'S1', '0'],
                                ['01', 'S0', 'S3', '0'],
                                ['00', 'S1', 'S2', '0'],
                                ['01', 'S1', 'S0', '0'],
                                ['00', 'S2', 'S3', '0'],
                                ['01', 'S2', 'S1', '0'],
                                ['00', 'S3', 'S0', '1'],
                                ['01', 'S3', 'S2', '1'],
                                ['1-', '*', 'S0', '']]}
    fsm = FSMGenerator(if_id, fsm_spec, use_analyzer=True)
    assert not fsm.running, \
        'FSM is not supposed to run after initialization.'

    # Start the FSM generator to generate pattern
    print("\nConnect D0 to GND, and D1 to 3V3 on Arduino header.")
    input("Hit enter after done ...")
    fsm.start(num_samples=num_samples, frequency_mhz=10)
    assert fsm.running, \
        'FSM is supposed to run after start.'

    for wavegroup in fsm.waveform.waveform_dict['signal']:
        if wavegroup[0] == 'analysis':
            for wavelane in wavegroup[1:]:
                if wavelane['name'] == 'test':
                    test_string1 = wavelane['wave']
    test_array1 = np.array(_bitstring_to_int(_wave_to_bitstring(test_string1)))

    tile1 = np.array([1, 0, 0, 0])
    matched = False
    for delay in range(4):
        tile2 = np.roll(tile1, delay)
        candidate_array = np.tile(tile2, int(num_samples/4))
        if np.array_equal(candidate_array, test_array1):
            matched = True
            break
    assert matched, 'Analysis result not matching the generated pattern.'

    # Running it the second time will simply do trace only
    fsm.start(num_samples=num_samples, frequency_mhz=10)
    assert fsm.running, \
        'FSM is supposed to run after start.'

    for wavegroup in fsm.waveform.waveform_dict['signal']:
        if wavegroup[0] == 'analysis':
            for wavelane in wavegroup[1:]:
                if wavelane['name'] == 'test':
                    test_string2 = wavelane['wave']
    test_array2 = np.array(_bitstring_to_int(_wave_to_bitstring(test_string2)))

    matched = False
    for delay in range(4):
        tile2 = np.roll(tile1, delay)
        candidate_array = np.tile(tile2, int(num_samples / 4))
        if np.array_equal(candidate_array, test_array2):
            matched = True
            break
    assert matched, 'Analysis result not matching the trace-only pattern.'

    # Stop the FSM generator and recapture, using state bits
    fsm.stop()
    assert not fsm.running, \
        'FSM is not supposed to run after stop.'

    print("Connect both D0 and D1 to GND on Arduino header.")
    input("Hit enter after done ...")
    fsm.parse_fsm_spec(fsm_spec, use_state_bits=True)
    fsm.start(num_samples=num_samples)
    assert fsm.running, \
        'FSM is supposed to run after start.'

    for wavegroup in fsm.waveform.waveform_dict['signal']:
        if wavegroup[0] == 'analysis':
            for wavelane in wavegroup[1:]:
                if wavelane['name'] == 'test':
                    test_string3 = wavelane['wave']
                if wavelane['name'] == 'state_bit0':
                    test_string4 = wavelane['wave']
                if wavelane['name'] == 'state_bit1':
                    test_string5 = wavelane['wave']
    test_array3 = np.array(_bitstring_to_int(_wave_to_bitstring(test_string3)))
    test_array4 = np.array(_bitstring_to_int(_wave_to_bitstring(test_string4)))
    test_array5 = np.array(_bitstring_to_int(_wave_to_bitstring(test_string5)))

    tile3 = np.array([0, 0, 0, 1])
    tile4 = np.array([0, 1, 0, 1])
    tile5 = np.array([0, 0, 1, 1])
    matched = False
    for delay in range(4):
        tile6 = np.roll(tile3, delay)
        tile7 = np.roll(tile4, delay)
        tile8 = np.roll(tile5, delay)
        candidate_array3 = np.tile(tile6, int(num_samples / 4))
        candidate_array4 = np.tile(tile7, int(num_samples / 4))
        candidate_array5 = np.tile(tile8, int(num_samples / 4))
        if np.array_equal(candidate_array3, test_array3):
            assert np.array_equal(candidate_array4, test_array4), \
                'State bit 0 not synchronized with output.'
            assert np.array_equal(candidate_array5, test_array5), \
                'State bit 1 not synchronized with output.'
            matched = True
            break
    assert matched, 'Analysis result not matching the generated pattern.'

    # Running it the second time will simply do trace only
    fsm.start(num_samples=num_samples)
    assert fsm.running, \
        'FSM is supposed to run after start.'

    for wavegroup in fsm.waveform.waveform_dict['signal']:
        if wavegroup[0] == 'analysis':
            for wavelane in wavegroup[1:]:
                if wavelane['name'] == 'test':
                    test_string3 = wavelane['wave']
                if wavelane['name'] == 'state_bit0':
                    test_string4 = wavelane['wave']
                if wavelane['name'] == 'state_bit1':
                    test_string5 = wavelane['wave']
    test_array3 = np.array(_bitstring_to_int(_wave_to_bitstring(test_string3)))
    test_array4 = np.array(_bitstring_to_int(_wave_to_bitstring(test_string4)))
    test_array5 = np.array(_bitstring_to_int(_wave_to_bitstring(test_string5)))

    matched = False
    for delay in range(4):
        tile6 = np.roll(tile3, delay)
        tile7 = np.roll(tile4, delay)
        tile8 = np.roll(tile5, delay)
        candidate_array3 = np.tile(tile6, int(num_samples / 4))
        candidate_array4 = np.tile(tile7, int(num_samples / 4))
        candidate_array5 = np.tile(tile8, int(num_samples / 4))
        if np.array_equal(candidate_array3, test_array3):
            assert np.array_equal(candidate_array4, test_array4), \
                'State bit 0 not synchronized with output.'
            assert np.array_equal(candidate_array5, test_array5), \
                'State bit 1 not synchronized with output.'
            matched = True
            break
    assert matched, 'Analysis result not matching the trace-only pattern.'

    ol.reset()
